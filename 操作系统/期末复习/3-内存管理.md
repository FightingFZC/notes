# 引入目的

更好的支持多道程序的并发执行，提高系统性能

# 主要功能

## 内存空间的分配和回收

rt

## 存储的保护与共享

保证各道作业在各自的存储空间内运行，互不干扰。

## 地址转换

在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址.

## 内存扩充

利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。

# 用户程序的主要处理阶段

1. 编辑阶段:创建源文件
2. 编译阶段:由编译程序将用户源代码编译成若干目标模块，生成目标文件
3. 链接阶段:由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。生成可执行文件（(形成逻辑地址)
4. 装入阶段:由装入程序将装入模块装入内存运行。
5. 运行阶段:得到结果

# 相关概念

## 程序的装入

1. 绝对装入:逻辑地址和实际的内存地址一致
2. 静态重定位:地址变换在装入时一次完成
3. 动态重定位:地址变换在执行程序时再完成

## 程序的链接

1. 静态链接
2. 装入时链接
3. 运行时链接

## 地址空间

1. 逻辑地址空间:地址从0开始
2. 物理地址空间:内存中物理单元的集合

# 管理方式

## 连续分配管理方式

1. 单一连续分配:分配到内存的固定的区域(有内存碎片)
   1. 内存碎片:没被用上的内存
2. 固定分区分配
   1. 分配到内存不同的固定区域，分区可以相等可以不等（内部碎片)
3. 动态分区分配
   1. 可变分区存储管理:按照程序的需要进行动态地划分
   2. 动态分区的分配策略算法
      1. 首次适应(最好):空闲分区以**地址递增的**次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区(**增大查找开销**)。
      2. 最佳适应:空闲分区按**容量递增的**方式形成分区链，找到第一个能满足要求的空闲分区（**外部碎片过多**)
         1. 外部碎片:内存由于太小而无法利用
      3. 最坏适应:空闲分区以**容量递减的**次序链接。找到第一个能满足要求的空闲分区，即挑选出最大的分区(对大进程不利)。
      4. 邻近适应:由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。

## 非连续分配管理方式

1. 基本分页式存储管理
2. 基本分段式存储管理
3. 段页式

# 内存扩充

1. 覆盖(同一进程或程序)
   1. 覆盖之前用的(之后可能不用)
2. 交换(不同作业/进程间进行)
   1. 把暂时不用的放到外存
3. 虚拟内存
   1. 引入原因:从逻辑上扩充内存
   2. 组成部分
      1. 页表机制
      2. 中断机制
      3. 地址交换机制
      4. 内存与外存
   3. 页面淘汰(置换)算法
      1. 先进先出(FIFO):如同其名
         1. 可能会导致贝拉迪异常
      2. 最近最久未用(LRU Least Recently Used):
         1. 就是找到最久没用的那个页替换掉
      3. 最近最少用(clock):
      4. 最优(最佳Optimal OPT):把以后不再使用的或最长时间内不会用到的页面淘汰出去(理论上，不会实现)
         1. 就是找到之后最长时间不会用到的页替换掉
      5. **注意**:页面淘汰是由缺页中断引起的,但缺页中断不见得一定引起页面淘汰
   4. 抖动
      1. 页面频繁的换进换出
      2. 原因:
         1. 分配给进程的进程块不够
   5. 页面分配的策略
      1. 固定分区局部置换(物理块不变)
      2. 可变分配局部置换(动态增加物理块)
      3. 可变分配全局置换(只允许从该进程的内存页面中挑选一页)
